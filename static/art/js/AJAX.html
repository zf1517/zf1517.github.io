<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
	<title>Document</title>
</head>
<style>
		.wrapper{
			margin: 0 auto;
			width: 96%;
			max-width: 800px;
			
		}
		h2{
			text-align: center;
		}
		p{
			text-indent: 2em;
			line-height: 1.5;
		}
		article{
			margin: 0 auto;
		}
		.code{
			background-color: #000;
			color: #fff;
			margin: 0 10%;
			overflow: auto;
		}
</style>
<body>
	<div class="wrapper">
		<article>
		<h2>AJAX</h2>
			<p>Ajax，是对Asynchronous JavaScript + XML 的简写。这一技术能够向服务器请求额外的数据而无须卸载页面，会带来更好的用户体验。 </p>
			<p>使用XHR 对象取得新数据，然后再通过DOM 将新数据插入到页面</p>
			<p>在使用XHR 对象时，要调用的第一个方法是open()，它接受3 个参数：要发送的请求的类型（”get”、”post”等）、请求的URL 和表示是否异步发送请求的布尔值。</p>
			<pre class="code">
var xhr = new XMLHttpRequest();
xhr.open("get", "example.php", false);
xhr.send(null);
			</pre>
			<p>由于这次请求是同步( 第三个参数设为false )的，javascript 代码会等到服务器响应之后再继续执行。在收到响应后，响应的数据会自动填充XHR 对象的属性，相关的属性简介如下:
			<ul>
				<li>responseText：作为响应主体被返回的文本。</li>
				<li>responseXML：如果响应的内容类型是"text/xml"或"application/xml"，这个属性中将保存包含着响应数据的XML DOM 文档。</li>
				<li>status：响应的HTTP 状态。(200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源网页等不存在 500 - 内部服务器错误)</li>
				<li>statusText：HTTP 状态的说明。</li>
			</ul></p>
			<p>像前面这样发送同步请求当然没有问题，但多数情况下，我们还是要发送异步请求，才能让JavaScript 继续执行而不必等待响应。此时，可以检测XHR 对象的readyState 属性，该属性表示请求/响应过程的当前活动阶段。另外，在接收到响应之前还可以调用abort()方法来取消异步请求，如下所示：xhr.abort();</p>
			<pre class="code">
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function(){
    if (xhr.readyState == 4){
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
            alert(xhr.responseText);
            var myHeader = xhr.getResponseHeader("MyHeader");
 			var allHeaders = xhr.getAllResponseHeaders();
        } else {
            alert("Request was unsuccessful: " + xhr.status);
        }
    }
};
xhr.open("get", "example.txt", true);
xhr.setRequestHeader("MyHeader", "MyValue");
xhr.send(null);
			</pre>
			<p>在XMLHttpRequest对象上绑定readystatechange事件可以监听其状态。<ul>
				<li>0: 请求未初始化</li>
				<li>1:服务器连接已建立</li>
				<li>2: 请求已接收</li>
				<li>3: 请求处理中</li>
				<li>4: 请求已完成，且响应已就绪</li>
			</ul></p>
			<p>每个HTTP 请求和响应都会带有相应的头部信息。不同浏览器实际发送的头部信息会有所不同。 使用setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段的名称和头部字段的值。要成功发送请求头部信息，必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()。</p>
			<p>调用XHR 对象的getResponseHeader()方法并传入头部字段名称，可以取得相应的响应头部信息。而调用getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串.</p>
			<h4>跨域小结</h4>
			<p>JSONP 是JSON with padding（填充式JSON 或参数式JSON）的简写. JSONP 是通过动态script元素来使用的，使用时可以为src 属性指定一个跨域URL。这里的script元素与img元素类似，都有能力不受限制地从其他域加载资源。因为JSONP 是有效的JavaScript 代码，所以在请求完成后，即在JSONP 响应加载到页面中以后，就会立即执行。</p>
			<pre class="code">
var script = document.createElement("script");
script.src = "http://freegeoip.net/json/?callback=handleResponse";
document.body.insertBefore(script, document.body.firstChild);
		    </pre>
		    <p>请求到的资源(立即执行)：</p>
		    <pre class="code">
handleResponse({"ip":"121.248.49.251","country_code":"CN","country_name":"涓浗","region_code":"32","region_name":"姹熻嫃鐪�","city":"鍗椾含","zip_code":"","time_zone":"Asia/Shanghai","latitude":32.0617,"longitude":118.7778,"metro_code":0});
		    </pre>
			<p>然后立即执行预定义的callback函数即handleResponse();</p>
			<pre class="code">
function handleResponse(response){
	alert("You’re at IP address " + response.ip + ", which is in " +
	response.city + ", " + response.region_name);
}
		</pre>
		<p>缺点： JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码。 要确定JSONP 请求是否失败并不容易。</p>
		</article>
	</div>
</body>
</html>