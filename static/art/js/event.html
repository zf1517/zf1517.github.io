<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
	<title>Document</title>
</head>
<style>
html,body{
	margin: 0;
	padding: 0;
	width: 100%;
}
		.wrapper{
			margin: 0 auto;
			width: 96%;
			max-width: 800px;
			
		}
		h2{
			text-align: center;
		}
		p{
			text-indent: 2em;
			line-height: 1.5;
		}
		article{
			margin: 0 auto;
		}
		.code{
			background-color: #000;
			color: #fff;
			margin: 0 10%;
			overflow: auto;
			
		}
</style>
<body>
	<div class="wrapper">
		<article>
		<h2>js事件</h2>
			<p>事件流描述的是从页面中接收事件的顺序。。IE 的事件流是事件冒泡流，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档。而Netscape Communicator 的事件流是事件捕获流，事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。</p>
			<p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应</p>
			<h4>1. DOM0级事件处理程序</h4>
			<p>通过JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。而且至今仍然为所有现代浏览器所支持。原因一是简单，二是具有跨浏览器的优势。</p><pre class="code">
var btn = document.getElementById("myBtn");
btn.onclick = function(){         //事件绑定
alert(this.id); //"myBtn"
};
btn.onclick = null; //删除事件处理程序
			</pre>
			<h4>2. DOM2级事件处理程序</h4>
			<p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法，并且它们都接受3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</p>
			<pre class="code">
var btn = document.getElementById("myBtn");
btn.addEventListener("click", function(){
alert(this.id);
}, false);
			</pre>
			<p>使用DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序,但是通过addEventListener()添加的匿名函数将无法移除。</p>
			<h4>3. IE事件处理程序</h4>
			<p>IE 实现了与DOM 中类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。</p>
			<pre class="code">
var btn = document.getElementById("myBtn");
btn.attachEvent("onclick", function(){
alert(this === window); //true 事件处理程序会在全局作用域中运行
});
			</pre>
			 <h4>4. 事件对象</h4>
			 <p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息</p>
			 <pre class="code">
var btn = document.getElementById("myBtn");
btn.onclick = function(event){
	alert(event.currentTarget === this); //绑定事件的元素
	alert(event.target === this); //true 触发事件的元素
	event.srcElement ===this;    //IE中事件目标
	event.preventDefault(); //取消事件的默认行为
	event.returnValue = false;//IE中取消事件的默认行为
	event.stopPropagation(); //取消事件的进一步捕获或冒泡
	event.cancelBubble = true; //IE取消事件的进一步冒泡
	event.type; //'click'
	event.clientX; //鼠标指针在视口中的水平坐标（客户坐标）
	event.pageX; //鼠标指针在页面中的水平坐标（在页面没有滚动的情况下，pageX 和pageY 的值与clientX 和clientY 的值相等）
	event.screenX; //屏幕坐标
	event.offsetX; //鼠标指针在目标元素中的坐标
};
			 </pre>
			 <h4>5. 鼠标和滚轮事件</h4>
			<p>DOM3 级事件中定义了9 个鼠标事件，简介如下。</p>
			<ul>
				<li>click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。</li>
				<li>dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发。</li>
				<li>mousedown：在用户按下了任意鼠标按钮时触发。</li>
				<li>mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发</li>
				<li>mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。</li>
				<li>mousemove：当鼠标指针在元素内部移动时重复地触发。</li>
				<li>mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。</li>
				<li>mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发</li>
				<li>mouseup：在用户释放鼠标按钮时触发。</li>
			</ul>
			<h4>6. 事件委托</h4>
			<p>对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，在包裹元素上只指定一个事件处理程序，就可以管理子元素上某一类型的所有事件</p>
			<pre class="code">
&lt;ul id="myLinks"&gt;
&lt;li id="goSomewhere"&gt;Go somewhere&lt;/li&gt;
&lt;li id="doSomething"&gt;Do something&lt;/li&gt;
&lt;li id="sayHi"&gt;Say hi&lt;/li&gt;
&lt;/ul&gt;

var par = document.querySelector('#myLinks');
par.onclick = function(event){
	var target = event.target;
	swtich (target.id){
		case 'goSomewhere':
			alert('1');
			break;
		case 'doSomething':
			alert('2');
			break;
		case 'sayHi':
			alert('3');
			break;
	}
}
			</pre>

		</article>
	</div>
</body>
</html>