<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,inital-scale=1.0,user-scalable=no">
	<title>Document</title>
</head>
<style>
		.wrapper{
			margin: 0 auto;
			width: 100%;
			max-width: 800px;
			padding: 10px;
			
		}
		h2{
			text-align: center;
		}
		p{
			text-indent: 2em;
			line-height: 1.5;
		}
		article{
			margin: 0 auto;
		}
		.code{
			background-color: #000;
			color: #fff;
			margin: 0 10%;
			
		}
</style>
<body>
	<div class="wrapper">
		<article>
		<h2>js函数的使用</h2>
			<h4>1. 函数在JavaScript中的三种使用模式</h4>
			<p>最简单的使用模式是普通的函数调用。</p>
			<pre class="code">
function hello(name){
	return "hello," + name;
}
hello('yaya');
			</pre>
			<p>第二种使用模式是方法调用。JavaScript中的方法是对象的属性恰好为函数时。</p>
			<pre class="code">
var obj = {
	hello:function(){
		return "hello"+this.name;
	},
	name:yaya
}
obj.hello();
			</pre>
			<p>绑定到this变量的对象称为调用的接收者，通常，通过某个对象调用方法则将该对象作为该方法的接收者。一个非方法的函数调用会将全局对象作为接收者。</p>
			<p>函数的第三种用法是通过构造函数使用，通过new方法得到构造函数的实例</p>
			<pre class="code">
function Hello(name){
	this.name = name;
	this.say = function(){
		alert(this.name)
	}
}
var h = new Hello('yaya');
			</pre>
			<p>new操作符具体干了三件事：第一，创建一个空对象obj；第二，将该空对象的_proto_属性指向构造函数的prototype；第三，将构造函数的this指向obj，然后调用构造函数。
			</p>
			<pre class="code">
var obj = {};
obj._proto_ = Hello.prototype;
Hello.call(obj);
			</pre>
			<h4>2. 高阶函数的使用</h4>
			<p>高阶函数是将函数作为参数或返回值的函数。</p>
			<p>当一个对象要调用不属于它的方法时，可以将该方法作为一个新的属性添加到接收者对象中，但是这种做法是十分危险的，因为有可能会覆盖该对象原有的同名属性。通过call方法将其接受者指定为该对象无疑是一种稳妥的方法。</p>
			<p>当一个函数的参数数目为不定时，怎么将一个参数数组传入呢？ 答案是利用apply方法，apply方法可以将数组的每个元素作为调用的单独参数。</p>
			<pre class="code">
var in =[1,2,3,4];
average.apply(null,in);</pre>
			<p>如何实现如上average()可变参数函数呢，我们可以利用arguments属性来实现，arguments给实参提供了一个类似数组的接口，为每个实参提供了一个索引属性，还包含一个length属性来指示参数的个数。arguments对象并不是一个数组，没有数组中如pshu()一样的方法，但我们可以利用call方法提取数组中的push使用。</p>
			<code class="code">Array.prototype.call(arguments)</code>
			<p>修改arguments对象并不安全，常见的做法是将argumens复制到一个新的数组。</p>
			<p>由于方法和值为函数的属性没有区别，因此很容易提取对象的方法并将其作为回调函数直接传递给高阶函数。但是这也会很容易忘记将提取出来的函数的接收者绑定到被提取出的对象上。</p>
			<pre class="code">
var buffer = {
	entries:[],
	add:function(s){
		this.entries.push(s);
	}
}
var source = [1,2,3];
souurce.forEach(buffer.add); //error entries undefined
			</pre>
			<p>回调函数一般有一个复制过程，故该方法是当作普通函数调用的，默认接收者是全局对象。将buffer.add()包裹到一个函数里是一种解决方案；对于数组的迭代方法，第二个参数可以指定回调的this值，这也是一种解决方案。更朴实的方法是利用bind方法绑定回调的this值，即buffer.add.bind(buffer).</p>
			<p>在实现异步编程是，常使用回调及其嵌套</p>
			<pre class="code">
db.lookupAsync('url',function(url){
	downloadAsync(url,function(file){
		downloadAsync('a.txt',function(a){
			......
		})
	})
})
			</pre>
			
		</article>
	</div>
</body>
</html>