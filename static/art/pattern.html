<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>正则表达式</title>
</head>
<style>
		.wrapper{
			margin: 30px auto;
			width: 80%;
			max-width: 800px;
			background: #EFEDED;
			
		}
		h2{
			text-align: center;
		}
		p{
			text-indent: 2em;
			line-height: 1.5;
		}
		article{
			margin: 0 auto;
		}
		code{
			background-color: #000;
			color: #fff;
			font-size: 1em;
			padding: 2px;
		}
		table{
			width: 50%;
			margin-left: 20%;
		}
		table,td,th{
			border:1px solid #222;
			text-align: center;
		}
</style>
<body>
	<div class="wrapper">
		<article>
		<h2>正则表达式基础</h2>
			<h4>1.概述</h4>
			<p>JavaScript中通过内置对象RegExp对象来支持正则表达式，有两种方法实例化RegExp对象</p>
			<ul>
				<li><span>字面量,例如：</span><code>var pattern = /\bat/g;</code></li>
				<li><span>构造函数(元字符必须转义\),例如：</span><code>var pattern2 = new RegExp{"\\bat","g"}</code></li>
			</ul>
			<h4>2.匹配模式</h4>
			<p>正则表达式的匹配模式支持下列三个标志：</p>
			<ul>
				<li>g : 表示全局（global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li>
				<li>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li>
				<li>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li>
			</ul>
			<h4>2.字符类与预定义类</h4>
			 <table>
			 	<tr><td>[...]</td>
			 	<td>位于括号内的任意字符</td></tr>
			 	<tr><td>[^...]</td>
			 	<td>不在括号内的任意字符</td></tr>
			 	<tr><td>.</td>
			 	<td>除换行符外的任意字符</td></tr>
			 	<tr><td>\w(\W)</td>
			 	<td>任意单字字符[a-zA-Z0-9](非)</td></tr>
			 	<tr><td>\s(\S)</td>
			 	<td>任意空白符（非）</td></tr>
			 	<tr><td>\d(\D)</td>
			 	<td>任意数字（非）</td></tr>
			 	<tr><td>\b[\B]</td>
			 	<td>字符边界(非)</td></tr>
			 	<tr><td>[\b]</td>
			 	<td>退格符</td></tr>
			 	<tr><td>^</td>
			 	<td>字符开头</td></tr>
			 	<tr><td>$</td>
			 	<td>字符结尾</td></tr>
			 </table>
			 <h4>3.范围类与量词</h4>
			 <table>
			 	<tr><td>[a-z]</td><td>a到z的所有小写字母</td></tr>
			 	<tr><td>{n,m}</td><td>匹配前一项n-m次</td</tr>
			 	<tr><td>{n}</td><td>匹配n次</td</tr>
			 	<tr><td>？</td><td>0或1次</td</tr>
			 	<tr><td>+</td><td>大于等于一次</td</tr>
			 	<tr><td>*</td><td>任意次</td</tr>
			 </table>
			 <h4>4.贪婪模式与非贪婪模式</h4>
			 <p>贪婪模式（默认）：正则表达式会尽可能多的匹配 <code>'12345678'.replace(/\d{3,6}/g/,'X') => 'X78'</code></p>
			 <p>非贪婪模式：正则表达式会尽可能少的匹配 <code>'12345678'.replace(/\d{3,6}？/g/,'X') => 'XX78'</code></p>
			 <h4>5.分组</h4>
			 <p>用（）进行分组。</p>
			 <ul>
			 	<li>在完整的模式中定义子模式：<code>'abababadfr'.replace('/(ab){3}/g','X') => 'XXXadfr'</code></li>
			 	<li>与选择符配合使用：<code>'codeabcode'.replace('/e(ab|cd)c/g','X' => 'codXode')</code></li>
			 	<li>把单独的项目分组成子表达式用于捕获(不想捕获时在括号内加入？：即可)：<code>'2017-07-30'.replace('/(\d{4})-(\d{2})-(\d{2})/g','$2-$3-$1') => '07-30-2017'</code></li>
			 </ul>
			<h4>6.RegExp实例方法</h4>
			 <ul>
			 	<li>test():该模式与参数匹配时返回true,同时更新lastIndex;<code>/\d/.test('23') => true;</code></li>
			 	<li>exec():返回包含匹配项信息的数组，该数组有两个属性index(匹配项在字符串中的位置)，input(该字符串)。 数组的结果分两种情况讨论：
			 	<ul>
			 		<li>非全局捕获时：正则表达式的lastIndex不生效，始终为0；结果数组第一项为匹配到的字符串，第二项是捕获到的字符串的第一个子表达式（如果有的话）。。。</li>
			 		<li>全局捕获时：lastIndex指向当次匹配到的字符串的第一个索引；结果数组与上类似；每执行一次，匹配到下一个字符串</li>
			 	</ul></li>
			 </ul>
			 <h4>7.字符串方法</h4>
			 <ul>
			 	<li>search():检索字符串中指定的子字符串，返回第一个匹配结果的index，查找不到返回-1；<code>'a1b2c3d1'.search('/1b/') => 1</code></li>
			 	<li>match():找到一个或多个和正则匹配的文本；非全局匹配时返回值与exec()相同，全局匹配时只返回匹配到的字符串数组</li>
			 	<li>split():用正则分割字符串；<code>'a1b2c3d4e'.split('/\d/g') => ['a','b','c','d','e']</code></li>
			 	<li>replace():用指定字符替换匹配正则；<code>'a1b1c1'.replace('/1/g','') => 'abc'</code></li>
			 </ul>
		</article>
	</div>
</body>
</html>